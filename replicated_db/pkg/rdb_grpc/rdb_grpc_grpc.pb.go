// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.23.3
// source: rdb_grpc.proto

package rdb_grpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	SubredditGRPC_GetSubreddit_FullMethodName    = "/rdb_grpc.SubredditGRPC/GetSubreddit"
	SubredditGRPC_CreateSubreddit_FullMethodName = "/rdb_grpc.SubredditGRPC/CreateSubreddit"
	SubredditGRPC_GetSubreddits_FullMethodName   = "/rdb_grpc.SubredditGRPC/GetSubreddits"
)

// SubredditGRPCClient is the client API for SubredditGRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SubredditGRPCClient interface {
	// we only need the subreddit handle (string)
	// but protobuf doesn't support primitives as paramaters
	GetSubreddit(ctx context.Context, in *Subreddit, opts ...grpc.CallOption) (*Subreddit, error)
	CreateSubreddit(ctx context.Context, in *Subreddit, opts ...grpc.CallOption) (*Subreddit, error)
	GetSubreddits(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SubredditList, error)
}

type subredditGRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewSubredditGRPCClient(cc grpc.ClientConnInterface) SubredditGRPCClient {
	return &subredditGRPCClient{cc}
}

func (c *subredditGRPCClient) GetSubreddit(ctx context.Context, in *Subreddit, opts ...grpc.CallOption) (*Subreddit, error) {
	out := new(Subreddit)
	err := c.cc.Invoke(ctx, SubredditGRPC_GetSubreddit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subredditGRPCClient) CreateSubreddit(ctx context.Context, in *Subreddit, opts ...grpc.CallOption) (*Subreddit, error) {
	out := new(Subreddit)
	err := c.cc.Invoke(ctx, SubredditGRPC_CreateSubreddit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subredditGRPCClient) GetSubreddits(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SubredditList, error) {
	out := new(SubredditList)
	err := c.cc.Invoke(ctx, SubredditGRPC_GetSubreddits_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubredditGRPCServer is the server API for SubredditGRPC service.
// All implementations must embed UnimplementedSubredditGRPCServer
// for forward compatibility
type SubredditGRPCServer interface {
	// we only need the subreddit handle (string)
	// but protobuf doesn't support primitives as paramaters
	GetSubreddit(context.Context, *Subreddit) (*Subreddit, error)
	CreateSubreddit(context.Context, *Subreddit) (*Subreddit, error)
	GetSubreddits(context.Context, *emptypb.Empty) (*SubredditList, error)
	mustEmbedUnimplementedSubredditGRPCServer()
}

// UnimplementedSubredditGRPCServer must be embedded to have forward compatible implementations.
type UnimplementedSubredditGRPCServer struct {
}

func (UnimplementedSubredditGRPCServer) GetSubreddit(context.Context, *Subreddit) (*Subreddit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubreddit not implemented")
}
func (UnimplementedSubredditGRPCServer) CreateSubreddit(context.Context, *Subreddit) (*Subreddit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubreddit not implemented")
}
func (UnimplementedSubredditGRPCServer) GetSubreddits(context.Context, *emptypb.Empty) (*SubredditList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubreddits not implemented")
}
func (UnimplementedSubredditGRPCServer) mustEmbedUnimplementedSubredditGRPCServer() {}

// UnsafeSubredditGRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubredditGRPCServer will
// result in compilation errors.
type UnsafeSubredditGRPCServer interface {
	mustEmbedUnimplementedSubredditGRPCServer()
}

func RegisterSubredditGRPCServer(s grpc.ServiceRegistrar, srv SubredditGRPCServer) {
	s.RegisterService(&SubredditGRPC_ServiceDesc, srv)
}

func _SubredditGRPC_GetSubreddit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Subreddit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubredditGRPCServer).GetSubreddit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubredditGRPC_GetSubreddit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubredditGRPCServer).GetSubreddit(ctx, req.(*Subreddit))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubredditGRPC_CreateSubreddit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Subreddit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubredditGRPCServer).CreateSubreddit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubredditGRPC_CreateSubreddit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubredditGRPCServer).CreateSubreddit(ctx, req.(*Subreddit))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubredditGRPC_GetSubreddits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubredditGRPCServer).GetSubreddits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubredditGRPC_GetSubreddits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubredditGRPCServer).GetSubreddits(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// SubredditGRPC_ServiceDesc is the grpc.ServiceDesc for SubredditGRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SubredditGRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rdb_grpc.SubredditGRPC",
	HandlerType: (*SubredditGRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSubreddit",
			Handler:    _SubredditGRPC_GetSubreddit_Handler,
		},
		{
			MethodName: "CreateSubreddit",
			Handler:    _SubredditGRPC_CreateSubreddit_Handler,
		},
		{
			MethodName: "GetSubreddits",
			Handler:    _SubredditGRPC_GetSubreddits_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rdb_grpc.proto",
}

const (
	PostGRPC_GetPost_FullMethodName   = "/rdb_grpc.PostGRPC/GetPost"
	PostGRPC_CreatPost_FullMethodName = "/rdb_grpc.PostGRPC/CreatPost"
	PostGRPC_GetPosts_FullMethodName  = "/rdb_grpc.PostGRPC/GetPosts"
	PostGRPC_Pin_FullMethodName       = "/rdb_grpc.PostGRPC/Pin"
	PostGRPC_Unpin_FullMethodName     = "/rdb_grpc.PostGRPC/Unpin"
	PostGRPC_UpVote_FullMethodName    = "/rdb_grpc.PostGRPC/UpVote"
	PostGRPC_DownVote_FullMethodName  = "/rdb_grpc.PostGRPC/DownVote"
)

// PostGRPCClient is the client API for PostGRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PostGRPCClient interface {
	GetPost(ctx context.Context, in *PostInfo, opts ...grpc.CallOption) (*Post, error)
	CreatPost(ctx context.Context, in *PostInfo, opts ...grpc.CallOption) (*Post, error)
	GetPosts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PostList, error)
	Pin(ctx context.Context, in *Post, opts ...grpc.CallOption) (*Post, error)
	Unpin(ctx context.Context, in *Post, opts ...grpc.CallOption) (*Post, error)
	UpVote(ctx context.Context, in *Post, opts ...grpc.CallOption) (*Post, error)
	DownVote(ctx context.Context, in *Post, opts ...grpc.CallOption) (*Post, error)
}

type postGRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewPostGRPCClient(cc grpc.ClientConnInterface) PostGRPCClient {
	return &postGRPCClient{cc}
}

func (c *postGRPCClient) GetPost(ctx context.Context, in *PostInfo, opts ...grpc.CallOption) (*Post, error) {
	out := new(Post)
	err := c.cc.Invoke(ctx, PostGRPC_GetPost_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postGRPCClient) CreatPost(ctx context.Context, in *PostInfo, opts ...grpc.CallOption) (*Post, error) {
	out := new(Post)
	err := c.cc.Invoke(ctx, PostGRPC_CreatPost_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postGRPCClient) GetPosts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PostList, error) {
	out := new(PostList)
	err := c.cc.Invoke(ctx, PostGRPC_GetPosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postGRPCClient) Pin(ctx context.Context, in *Post, opts ...grpc.CallOption) (*Post, error) {
	out := new(Post)
	err := c.cc.Invoke(ctx, PostGRPC_Pin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postGRPCClient) Unpin(ctx context.Context, in *Post, opts ...grpc.CallOption) (*Post, error) {
	out := new(Post)
	err := c.cc.Invoke(ctx, PostGRPC_Unpin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postGRPCClient) UpVote(ctx context.Context, in *Post, opts ...grpc.CallOption) (*Post, error) {
	out := new(Post)
	err := c.cc.Invoke(ctx, PostGRPC_UpVote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postGRPCClient) DownVote(ctx context.Context, in *Post, opts ...grpc.CallOption) (*Post, error) {
	out := new(Post)
	err := c.cc.Invoke(ctx, PostGRPC_DownVote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PostGRPCServer is the server API for PostGRPC service.
// All implementations must embed UnimplementedPostGRPCServer
// for forward compatibility
type PostGRPCServer interface {
	GetPost(context.Context, *PostInfo) (*Post, error)
	CreatPost(context.Context, *PostInfo) (*Post, error)
	GetPosts(context.Context, *emptypb.Empty) (*PostList, error)
	Pin(context.Context, *Post) (*Post, error)
	Unpin(context.Context, *Post) (*Post, error)
	UpVote(context.Context, *Post) (*Post, error)
	DownVote(context.Context, *Post) (*Post, error)
	mustEmbedUnimplementedPostGRPCServer()
}

// UnimplementedPostGRPCServer must be embedded to have forward compatible implementations.
type UnimplementedPostGRPCServer struct {
}

func (UnimplementedPostGRPCServer) GetPost(context.Context, *PostInfo) (*Post, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPost not implemented")
}
func (UnimplementedPostGRPCServer) CreatPost(context.Context, *PostInfo) (*Post, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatPost not implemented")
}
func (UnimplementedPostGRPCServer) GetPosts(context.Context, *emptypb.Empty) (*PostList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPosts not implemented")
}
func (UnimplementedPostGRPCServer) Pin(context.Context, *Post) (*Post, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pin not implemented")
}
func (UnimplementedPostGRPCServer) Unpin(context.Context, *Post) (*Post, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unpin not implemented")
}
func (UnimplementedPostGRPCServer) UpVote(context.Context, *Post) (*Post, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpVote not implemented")
}
func (UnimplementedPostGRPCServer) DownVote(context.Context, *Post) (*Post, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownVote not implemented")
}
func (UnimplementedPostGRPCServer) mustEmbedUnimplementedPostGRPCServer() {}

// UnsafePostGRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PostGRPCServer will
// result in compilation errors.
type UnsafePostGRPCServer interface {
	mustEmbedUnimplementedPostGRPCServer()
}

func RegisterPostGRPCServer(s grpc.ServiceRegistrar, srv PostGRPCServer) {
	s.RegisterService(&PostGRPC_ServiceDesc, srv)
}

func _PostGRPC_GetPost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostGRPCServer).GetPost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostGRPC_GetPost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostGRPCServer).GetPost(ctx, req.(*PostInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostGRPC_CreatPost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostGRPCServer).CreatPost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostGRPC_CreatPost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostGRPCServer).CreatPost(ctx, req.(*PostInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostGRPC_GetPosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostGRPCServer).GetPosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostGRPC_GetPosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostGRPCServer).GetPosts(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostGRPC_Pin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Post)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostGRPCServer).Pin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostGRPC_Pin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostGRPCServer).Pin(ctx, req.(*Post))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostGRPC_Unpin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Post)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostGRPCServer).Unpin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostGRPC_Unpin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostGRPCServer).Unpin(ctx, req.(*Post))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostGRPC_UpVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Post)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostGRPCServer).UpVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostGRPC_UpVote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostGRPCServer).UpVote(ctx, req.(*Post))
	}
	return interceptor(ctx, in, info, handler)
}

func _PostGRPC_DownVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Post)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostGRPCServer).DownVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PostGRPC_DownVote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostGRPCServer).DownVote(ctx, req.(*Post))
	}
	return interceptor(ctx, in, info, handler)
}

// PostGRPC_ServiceDesc is the grpc.ServiceDesc for PostGRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PostGRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rdb_grpc.PostGRPC",
	HandlerType: (*PostGRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPost",
			Handler:    _PostGRPC_GetPost_Handler,
		},
		{
			MethodName: "CreatPost",
			Handler:    _PostGRPC_CreatPost_Handler,
		},
		{
			MethodName: "GetPosts",
			Handler:    _PostGRPC_GetPosts_Handler,
		},
		{
			MethodName: "Pin",
			Handler:    _PostGRPC_Pin_Handler,
		},
		{
			MethodName: "Unpin",
			Handler:    _PostGRPC_Unpin_Handler,
		},
		{
			MethodName: "UpVote",
			Handler:    _PostGRPC_UpVote_Handler,
		},
		{
			MethodName: "DownVote",
			Handler:    _PostGRPC_DownVote_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rdb_grpc.proto",
}

const (
	UserGRPC_GetUser_FullMethodName        = "/rdb_grpc.UserGRPC/GetUser"
	UserGRPC_CreateUser_FullMethodName     = "/rdb_grpc.UserGRPC/CreateUser"
	UserGRPC_IncreaseKarma_FullMethodName  = "/rdb_grpc.UserGRPC/IncreaseKarma"
	UserGRPC_DecreaseKarma_FullMethodName  = "/rdb_grpc.UserGRPC/DecreaseKarma"
	UserGRPC_Follow_FullMethodName         = "/rdb_grpc.UserGRPC/Follow"
	UserGRPC_Unfollow_FullMethodName       = "/rdb_grpc.UserGRPC/Unfollow"
	UserGRPC_JoinSubreddit_FullMethodName  = "/rdb_grpc.UserGRPC/JoinSubreddit"
	UserGRPC_LeaveSubreddit_FullMethodName = "/rdb_grpc.UserGRPC/LeaveSubreddit"
)

// UserGRPCClient is the client API for UserGRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserGRPCClient interface {
	GetUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	IncreaseKarma(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	DecreaseKarma(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	Follow(ctx context.Context, in *UserFollowage, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Unfollow(ctx context.Context, in *UserFollowage, opts ...grpc.CallOption) (*emptypb.Empty, error)
	JoinSubreddit(ctx context.Context, in *UserSubredditMembership, opts ...grpc.CallOption) (*emptypb.Empty, error)
	LeaveSubreddit(ctx context.Context, in *UserSubredditMembership, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userGRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewUserGRPCClient(cc grpc.ClientConnInterface) UserGRPCClient {
	return &userGRPCClient{cc}
}

func (c *userGRPCClient) GetUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, UserGRPC_GetUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGRPCClient) CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, UserGRPC_CreateUser_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGRPCClient) IncreaseKarma(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, UserGRPC_IncreaseKarma_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGRPCClient) DecreaseKarma(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, UserGRPC_DecreaseKarma_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGRPCClient) Follow(ctx context.Context, in *UserFollowage, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserGRPC_Follow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGRPCClient) Unfollow(ctx context.Context, in *UserFollowage, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserGRPC_Unfollow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGRPCClient) JoinSubreddit(ctx context.Context, in *UserSubredditMembership, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserGRPC_JoinSubreddit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userGRPCClient) LeaveSubreddit(ctx context.Context, in *UserSubredditMembership, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserGRPC_LeaveSubreddit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserGRPCServer is the server API for UserGRPC service.
// All implementations must embed UnimplementedUserGRPCServer
// for forward compatibility
type UserGRPCServer interface {
	GetUser(context.Context, *User) (*User, error)
	CreateUser(context.Context, *User) (*User, error)
	IncreaseKarma(context.Context, *User) (*User, error)
	DecreaseKarma(context.Context, *User) (*User, error)
	Follow(context.Context, *UserFollowage) (*emptypb.Empty, error)
	Unfollow(context.Context, *UserFollowage) (*emptypb.Empty, error)
	JoinSubreddit(context.Context, *UserSubredditMembership) (*emptypb.Empty, error)
	LeaveSubreddit(context.Context, *UserSubredditMembership) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserGRPCServer()
}

// UnimplementedUserGRPCServer must be embedded to have forward compatible implementations.
type UnimplementedUserGRPCServer struct {
}

func (UnimplementedUserGRPCServer) GetUser(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserGRPCServer) CreateUser(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserGRPCServer) IncreaseKarma(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncreaseKarma not implemented")
}
func (UnimplementedUserGRPCServer) DecreaseKarma(context.Context, *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecreaseKarma not implemented")
}
func (UnimplementedUserGRPCServer) Follow(context.Context, *UserFollowage) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Follow not implemented")
}
func (UnimplementedUserGRPCServer) Unfollow(context.Context, *UserFollowage) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unfollow not implemented")
}
func (UnimplementedUserGRPCServer) JoinSubreddit(context.Context, *UserSubredditMembership) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinSubreddit not implemented")
}
func (UnimplementedUserGRPCServer) LeaveSubreddit(context.Context, *UserSubredditMembership) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveSubreddit not implemented")
}
func (UnimplementedUserGRPCServer) mustEmbedUnimplementedUserGRPCServer() {}

// UnsafeUserGRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserGRPCServer will
// result in compilation errors.
type UnsafeUserGRPCServer interface {
	mustEmbedUnimplementedUserGRPCServer()
}

func RegisterUserGRPCServer(s grpc.ServiceRegistrar, srv UserGRPCServer) {
	s.RegisterService(&UserGRPC_ServiceDesc, srv)
}

func _UserGRPC_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGRPCServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserGRPC_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGRPCServer).GetUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGRPC_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGRPCServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserGRPC_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGRPCServer).CreateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGRPC_IncreaseKarma_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGRPCServer).IncreaseKarma(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserGRPC_IncreaseKarma_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGRPCServer).IncreaseKarma(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGRPC_DecreaseKarma_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGRPCServer).DecreaseKarma(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserGRPC_DecreaseKarma_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGRPCServer).DecreaseKarma(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGRPC_Follow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserFollowage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGRPCServer).Follow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserGRPC_Follow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGRPCServer).Follow(ctx, req.(*UserFollowage))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGRPC_Unfollow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserFollowage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGRPCServer).Unfollow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserGRPC_Unfollow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGRPCServer).Unfollow(ctx, req.(*UserFollowage))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGRPC_JoinSubreddit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSubredditMembership)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGRPCServer).JoinSubreddit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserGRPC_JoinSubreddit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGRPCServer).JoinSubreddit(ctx, req.(*UserSubredditMembership))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserGRPC_LeaveSubreddit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSubredditMembership)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserGRPCServer).LeaveSubreddit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserGRPC_LeaveSubreddit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserGRPCServer).LeaveSubreddit(ctx, req.(*UserSubredditMembership))
	}
	return interceptor(ctx, in, info, handler)
}

// UserGRPC_ServiceDesc is the grpc.ServiceDesc for UserGRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserGRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rdb_grpc.UserGRPC",
	HandlerType: (*UserGRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUser",
			Handler:    _UserGRPC_GetUser_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _UserGRPC_CreateUser_Handler,
		},
		{
			MethodName: "IncreaseKarma",
			Handler:    _UserGRPC_IncreaseKarma_Handler,
		},
		{
			MethodName: "DecreaseKarma",
			Handler:    _UserGRPC_DecreaseKarma_Handler,
		},
		{
			MethodName: "Follow",
			Handler:    _UserGRPC_Follow_Handler,
		},
		{
			MethodName: "Unfollow",
			Handler:    _UserGRPC_Unfollow_Handler,
		},
		{
			MethodName: "JoinSubreddit",
			Handler:    _UserGRPC_JoinSubreddit_Handler,
		},
		{
			MethodName: "LeaveSubreddit",
			Handler:    _UserGRPC_LeaveSubreddit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rdb_grpc.proto",
}

const (
	CommentGRPC_AddComment_FullMethodName = "/rdb_grpc.CommentGRPC/AddComment"
	CommentGRPC_UpVote_FullMethodName     = "/rdb_grpc.CommentGRPC/UpVote"
	CommentGRPC_DownVote_FullMethodName   = "/rdb_grpc.CommentGRPC/DownVote"
)

// CommentGRPCClient is the client API for CommentGRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommentGRPCClient interface {
	AddComment(ctx context.Context, in *CommentInfo, opts ...grpc.CallOption) (*Comment, error)
	UpVote(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Comment, error)
	DownVote(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Comment, error)
}

type commentGRPCClient struct {
	cc grpc.ClientConnInterface
}

func NewCommentGRPCClient(cc grpc.ClientConnInterface) CommentGRPCClient {
	return &commentGRPCClient{cc}
}

func (c *commentGRPCClient) AddComment(ctx context.Context, in *CommentInfo, opts ...grpc.CallOption) (*Comment, error) {
	out := new(Comment)
	err := c.cc.Invoke(ctx, CommentGRPC_AddComment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentGRPCClient) UpVote(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Comment, error) {
	out := new(Comment)
	err := c.cc.Invoke(ctx, CommentGRPC_UpVote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentGRPCClient) DownVote(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Comment, error) {
	out := new(Comment)
	err := c.cc.Invoke(ctx, CommentGRPC_DownVote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommentGRPCServer is the server API for CommentGRPC service.
// All implementations must embed UnimplementedCommentGRPCServer
// for forward compatibility
type CommentGRPCServer interface {
	AddComment(context.Context, *CommentInfo) (*Comment, error)
	UpVote(context.Context, *Comment) (*Comment, error)
	DownVote(context.Context, *Comment) (*Comment, error)
	mustEmbedUnimplementedCommentGRPCServer()
}

// UnimplementedCommentGRPCServer must be embedded to have forward compatible implementations.
type UnimplementedCommentGRPCServer struct {
}

func (UnimplementedCommentGRPCServer) AddComment(context.Context, *CommentInfo) (*Comment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddComment not implemented")
}
func (UnimplementedCommentGRPCServer) UpVote(context.Context, *Comment) (*Comment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpVote not implemented")
}
func (UnimplementedCommentGRPCServer) DownVote(context.Context, *Comment) (*Comment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownVote not implemented")
}
func (UnimplementedCommentGRPCServer) mustEmbedUnimplementedCommentGRPCServer() {}

// UnsafeCommentGRPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommentGRPCServer will
// result in compilation errors.
type UnsafeCommentGRPCServer interface {
	mustEmbedUnimplementedCommentGRPCServer()
}

func RegisterCommentGRPCServer(s grpc.ServiceRegistrar, srv CommentGRPCServer) {
	s.RegisterService(&CommentGRPC_ServiceDesc, srv)
}

func _CommentGRPC_AddComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommentInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentGRPCServer).AddComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentGRPC_AddComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentGRPCServer).AddComment(ctx, req.(*CommentInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentGRPC_UpVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentGRPCServer).UpVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentGRPC_UpVote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentGRPCServer).UpVote(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentGRPC_DownVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentGRPCServer).DownVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentGRPC_DownVote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentGRPCServer).DownVote(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

// CommentGRPC_ServiceDesc is the grpc.ServiceDesc for CommentGRPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommentGRPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rdb_grpc.CommentGRPC",
	HandlerType: (*CommentGRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddComment",
			Handler:    _CommentGRPC_AddComment_Handler,
		},
		{
			MethodName: "UpVote",
			Handler:    _CommentGRPC_UpVote_Handler,
		},
		{
			MethodName: "DownVote",
			Handler:    _CommentGRPC_DownVote_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rdb_grpc.proto",
}
